var targetSections = null;
if (Input.root.sectionNames != null) {
    targetSections = Model!Section.all.select(t|Input.root.sectionNames.includes(t.name));
}

Output.root.matched = Model!Representation.all
    .select(r|
        ((Input.root.sectionNames   != null and (not r.sections.excludesAll(targetSections)))   or (Input.root.sectionNames == null)) and   // Apply section check
        ((Input.root.types          != null and Input.root.types.includes(r.type().name))       or (Input.root.types        == null)) and   // Apply type check
        ((Input.root.aabbMin        != null and r.hasProperty("area") and overlapBound(r.area)) or (Input.root.aabbMin      == null))       // Apply bound check
    )
    .collect(r|r.name).asSequence();

operation overlapBound(area: Model!Area): Boolean {
    return overlapAxis(area, 0) and overlapAxis(area, 1) and overlapAxis(area, 2);
}

operation overlapAxis(area: Model!Area, axis: Integer): Boolean {
    var smallMin = area.aabbMin[axis] < Input.root.aabbMin[axis];
    var largeMin = area.aabbMin[axis] > Input.root.aabbMax[axis];
    var smallMax = area.aabbMax[axis] < Input.root.aabbMin[axis];
    var largeMax = area.aabbMax[axis] > Input.root.aabbMax[axis];

    return ((not smallMin) and (not largeMin)) or ((not smallMax) and (not largeMax)) or (smallMin and largeMax);
}