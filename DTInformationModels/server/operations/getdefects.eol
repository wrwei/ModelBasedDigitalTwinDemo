var targetSurfaces = null;
if (Input.root.surfaceNames != null) {
    targetSurfaces = Model!Surface.all.select(s|Input.root.surfaceNames.includes(s.name));
}

var defects = Model!SurfaceDefect.all
    .select(d|
        ((Input.root.surfaceNames   != null and targetSurfaces.includes(d.surface))              or (Input.root.surfaceNames == null)) and   // Apply section check
        ((Input.root.types          != null and Input.root.types.includes(d.type.asString()))   or (Input.root.types        == null)) and   // Apply type check
        ((Input.root.aabbMin        != null and overlapBound(d.location))                       or (Input.root.aabbMin      == null))       // Apply bound check
    );

Output.root.descriptions = new Sequence;
Output.root.types = new Sequence;
Output.root.locations = new Sequence;
Output.root.surfaces = new Sequence;
Output.root.names = new Sequence;

for (d in defects) {
    Output.root.descriptions.add(d.description);
    Output.root.types.add(d.type.asString());
    Output.root.locations.add(d.location);
    Output.root.surfaces.add(d.surface.name);
    Output.root.names.add(d.name);
}

operation overlapBound(point: Collection): Boolean {
    return overlapAxis(point.at(0), 0) and overlapAxis(point.at(1), 1) and overlapAxis(point.at(2), 2);
}

operation overlapAxis(point: Real, axis: Integer): Boolean {
    return point >= Input.root.aabbMin[axis] and point <= Input.root.aabbMax[axis];
}